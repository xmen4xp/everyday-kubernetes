// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	customerrors "errors"
	"fmt"
	"os"
	"reflect"
	"strconv"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/rest"
	cache "k8s.io/client-go/tools/cache"

	baseClientset "perfdm/build/client/clientset/versioned"
	fakeBaseClienset "perfdm/build/client/clientset/versioned/fake"
	"perfdm/build/common"
	"perfdm/build/helper"

	baserootsockshopcomv1 "perfdm/build/apis/root.sockshop.com/v1"

	informerrootsockshopcomv1 "perfdm/build/client/informers/externalversions/root.sockshop.com/v1"
)

var log = logrus.New()

const maxRetryCount = 12
const sleepTime = 5
const ownershipAnnotation string = "Ownership"

// informerResyncPeriod is in second, default value is 10 Hrs(36000 Sec). INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
var informerResyncPeriod time.Duration = 36000

type Clientset struct {
	baseClient     baseClientset.Interface
	dynamicClient  *dynamic.DynamicClient
	rootSockshopV1 *RootSockshopV1
}

type subscription struct {
	informer          cache.SharedIndexInformer
	stop              chan struct{}
	WriteCacheObjects *sync.Map
}

// subscriptionMap will store crd string as key and value as subscription type,
// for example key="roots.orgchart.vmware.org" and value=subscription{}
var subscriptionMap = sync.Map{}

func subscribe(key string, informer cache.SharedIndexInformer) {
	s := subscription{
		informer:          informer,
		stop:              make(chan struct{}),
		WriteCacheObjects: &sync.Map{},
	}
	go s.informer.Run(s.stop)
	subscriptionMap.Store(key, s)
}

func (c *Clientset) SubscribeAll() {
	var key string

	key = "sockshops.root.sockshop.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootsockshopcomv1.NewSockShopInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "sockses.root.sockshop.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootsockshopcomv1.NewSocksInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "orderses.root.sockshop.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootsockshopcomv1.NewOrdersInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "shippings.root.sockshop.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootsockshopcomv1.NewShippingInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

}

func (c *Clientset) UnsubscribeAll() {
	subscriptionMap.Range(func(key, s interface{}) bool {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
		return true
	})
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}

	customFormatter := new(logrus.TextFormatter)
	customFormatter.TimestampFormat = "2006-01-02 15:04:05"
	log.SetFormatter(customFormatter)
	customFormatter.FullTimestamp = true
	if os.Getenv("NEXUS_LOG_LEVEL") == "debug" {
		log.SetLevel(logrus.DebugLevel)
		log.Debug("Nexus debug log enabled")
	}

	// INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
	stringResyncPeriod := os.Getenv("INFORMER_RESYNC_PERIOD")
	if stringResyncPeriod != "" {
		intResyncPeriod, err := strconv.Atoi(stringResyncPeriod)
		if err != nil {
			log.Errorf("env INFORMER_RESYNC_PERIOD is not set with correct value")
		} else {
			informerResyncPeriod = time.Duration(intResyncPeriod)
			log.Debugf("Resync Period for informers is set to %+v second", informerResyncPeriod)
		}
	}

	client := &Clientset{}
	client.baseClient = baseClient
	client.dynamicClient, _ = dynamic.NewForConfig(config) // TBD: check and react for error
	client.rootSockshopV1 = newRootSockshopV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.rootSockshopV1 = newRootSockshopV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Root() *RootSockshopV1 {
	return c.rootSockshopV1
}

type RootSockshopV1 struct {
	client *Clientset
}

func newRootSockshopV1(client *Clientset) *RootSockshopV1 {
	return &RootSockshopV1{
		client: client,
	}
}

// GetSockShopByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) GetSockShopByName(ctx context.Context, hashedName string) (*RootSockShop, error) {
	key := "sockshops.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetSockShopByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baserootsockshopcomv1.SockShop)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetSockShopByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baserootsockshopcomv1.SockShop).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetSockShopByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RootSockShop{
					client:   group.client,
					SockShop: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RootSockShop{
				client:   group.client,
				SockShop: resWrCache.(*baserootsockshopcomv1.SockShop),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootSockshopV1().
			SockShops().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RootSockShop{
				client:   group.client,
				SockShop: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetSockShopByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get SockShops: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetSockShopByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetSockShopByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadSockShopByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) ForceReadSockShopByName(ctx context.Context, hashedName string) (*RootSockShop, error) {
	log.Debugf("[ForceReadSockShopByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootSockshopV1().
			SockShops().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadSockShopByName] Failed to Get SockShops: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get SockShops: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadSockShopByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadSockShopByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadSockShopByName] Executed Successfully :%s", hashedName)
			return &RootSockShop{
				client:   group.client,
				SockShop: result,
			}, nil
		}
	}
}

// DeleteSockShopByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) DeleteSockShopByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteSockShopByName] Received objectToDelete: %s", hashedName)

	var (
		retryCount int
		result     *baserootsockshopcomv1.SockShop
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			SockShops().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteSockShopByName] Failed to get SockShops: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get SockShops: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteSockShopByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteSockShopByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteSockShopByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, v := range result.Spec.InventoryGvk {
		err := group.client.
			Root().DeleteSocksByName(ctx, v.Name)
		if err != nil {
			if errors.IsNotFound(err) {
				continue
			} else {
				return err
			}
		}
	}

	for _, v := range result.Spec.POGvk {
		err := group.client.
			Root().DeleteOrdersByName(ctx, v.Name)
		if err != nil {
			if errors.IsNotFound(err) {
				continue
			} else {
				return err
			}
		}
	}

	for _, v := range result.Spec.ShippingLedgerGvk {
		err := group.client.
			Root().DeleteShippingByName(ctx, v.Name)
		if err != nil {
			if errors.IsNotFound(err) {
				continue
			} else {
				return err
			}
		}
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RootSockshopV1().
			SockShops().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteSockShopByName] failed to delete SockShops: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete SockShops: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteSockShopByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteSockShopByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteSockShopByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("sockshops.root.sockshop.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	return
}

// CreateSockShopByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RootSockshopV1) CreateSockShopByName(ctx context.Context,
	objToCreate *baserootsockshopcomv1.SockShop) (*RootSockShop, error) {
	log.Debugf("[CreateSockShopByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.InventoryGvk = nil
	objToCreate.Spec.POGvk = nil
	objToCreate.Spec.ShippingLedgerGvk = nil

	var (
		retryCount int
		result     *baserootsockshopcomv1.SockShop
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			SockShops().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateSockShopByName] Failed to create SockShop: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create SockShop: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateSockShopByName] context canceled while creating SockShop: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[CreateSockShopByName] found unexpected error while creating SockShop: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateSockShopByName] SockShop: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("sockshops.root.sockshop.com"); ok {
				log.Debugf("[CreateSockShopByName] SockShop: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	log.Debugf("[CreateSockShopByName] Executed Successfully: %s", objToCreate.GetName())
	return &RootSockShop{
		client:   group.client,
		SockShop: result,
	}, nil
}

// UpdateSockShopByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RootSockshopV1) UpdateSockShopByName(ctx context.Context,
	objToUpdate *baserootsockshopcomv1.SockShop) (*RootSockShop, error) {
	log.Debugf("[UpdateSockShopByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Root().GetSockShopByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["sockshops.root.sockshop.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.OrgName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.OrgName).IsNil() {
			patchValueOrgName := objToUpdate.Spec.OrgName
			patchOpOrgName := PatchOp{
				Op:    "replace",
				Path:  "/spec/orgName",
				Value: patchValueOrgName,
			}
			patch = append(patch, patchOpOrgName)
		}
	} else {
		patchValueOrgName := objToUpdate.Spec.OrgName
		patchOpOrgName := PatchOp{
			Op:    "replace",
			Path:  "/spec/orgName",
			Value: patchValueOrgName,
		}
		patch = append(patch, patchOpOrgName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Location)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Location).IsNil() {
			patchValueLocation := objToUpdate.Spec.Location
			patchOpLocation := PatchOp{
				Op:    "replace",
				Path:  "/spec/location",
				Value: patchValueLocation,
			}
			patch = append(patch, patchOpLocation)
		}
	} else {
		patchValueLocation := objToUpdate.Spec.Location
		patchOpLocation := PatchOp{
			Op:    "replace",
			Path:  "/spec/location",
			Value: patchValueLocation,
		}
		patch = append(patch, patchOpLocation)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Website)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Website).IsNil() {
			patchValueWebsite := objToUpdate.Spec.Website
			patchOpWebsite := PatchOp{
				Op:    "replace",
				Path:  "/spec/website",
				Value: patchValueWebsite,
			}
			patch = append(patch, patchOpWebsite)
		}
	} else {
		patchValueWebsite := objToUpdate.Spec.Website
		patchOpWebsite := PatchOp{
			Op:    "replace",
			Path:  "/spec/website",
			Value: patchValueWebsite,
		}
		patch = append(patch, patchOpWebsite)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baserootsockshopcomv1.SockShop
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			SockShops().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateSockShopByName] Failed to patch SockShop gvk in parent node[]: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching gvk: %s", objToUpdate.GetName())
					log.Debugf("Trigger SockShop Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteSockShopByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting SockShop: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("SockShop deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateSockShopByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateSockShopByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger SockShop Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteSockShopByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting SockShop: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("SockShop Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateSockShopByName] Patch SockShop Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("sockshops.root.sockshop.com"); ok {
				log.Debugf("[UpdateSockShopByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateSockShopByName] Executed Successfully %s", objToUpdate.GetName())
	return &RootSockShop{
		client:   group.client,
		SockShop: result,
	}, nil
}

// ListSockShops returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RootSockshopV1) ListSockShops(ctx context.Context,
	opts metav1.ListOptions) (result []*RootSockShop, err error) {
	key := "sockshops.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RootSockShop, len(items))
		for k, v := range items {
			item, _ := v.(*baserootsockshopcomv1.SockShop)
			result[k] = &RootSockShop{
				client:   group.client,
				SockShop: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RootSockshopV1().
			SockShops().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RootSockShop, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RootSockShop{
				client:   group.client,
				SockShop: &item,
			}
		}
	}
	return
}

type RootSockShop struct {
	client *Clientset
	*baserootsockshopcomv1.SockShop
}

// Delete removes obj and all it's children from the database.
func (obj *RootSockShop) Delete(ctx context.Context) error {
	err := obj.client.Root().DeleteSockShopByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.SockShop = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RootSockShop) Update(ctx context.Context) error {
	result, err := obj.client.Root().UpdateSockShopByName(ctx, obj.SockShop)
	if err != nil {
		return err
	}
	obj.SockShop = result.SockShop
	return nil
}

// GetRootSockShop calculates the hashed name based on parents and
// returns given object
func (c *Clientset) GetRootSockShop(ctx context.Context) (result *RootSockShop, err error) {
	hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nil, helper.DEFAULT_KEY)
	return c.Root().GetSockShopByName(ctx, hashedName)
}

func (c *Clientset) RootSockShop() *sockshopRootSockshopV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["sockshops.root.sockshop.com"] = helper.DEFAULT_KEY
	return &sockshopRootSockshopV1Chainer{
		client:       c,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// AddRootSockShop calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DEFAULT_KEY) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddRootSockShop(ctx context.Context,
	objToCreate *baserootsockshopcomv1.SockShop) (result *RootSockShop, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Root().CreateSockShopByName(ctx, objToCreate)
}

// DeleteRootSockShop calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) DeleteRootSockShop(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nil, helper.DEFAULT_KEY)
	return c.Root().DeleteSockShopByName(ctx, hashedName)
}

type RootSockShopInventory struct {
	client    *Clientset
	Inventory []baserootsockshopcomv1.Child
}

func (n *RootSockShopInventory) Next(ctx context.Context) (*RootSocks, error) {
	for index, child := range n.Inventory {
		obj, err := n.client.Root().GetSocksByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Inventory)-1 {
				n.Inventory = nil
			} else {
				n.Inventory = n.Inventory[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllInventoryIter returns an iterator for all children of given type
func (obj *RootSockShop) GetAllInventoryIter(ctx context.Context) (
	result RootSockShopInventory) {
	result.client = obj.client
	result.Inventory = make([]baserootsockshopcomv1.Child, 0, len(obj.Spec.InventoryGvk))
	for _, v := range obj.Spec.InventoryGvk {
		result.Inventory = append(result.Inventory, v)
	}
	return
}

// GetAllInventory returns all children of a given type
func (obj *RootSockShop) GetAllInventory(ctx context.Context) (
	result []*RootSocks, err error) {
	result = make([]*RootSocks, 0, len(obj.Spec.InventoryGvk))
	for _, v := range obj.Spec.InventoryGvk {
		l, err := obj.client.Root().GetSocksByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetInventory returns child which has given displayName
func (obj *RootSockShop) GetInventory(ctx context.Context,
	displayName string) (result *RootSocks, err error) {
	l, ok := obj.Spec.InventoryGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Root.SockShop", "Inventory", displayName)
	}
	result, err = obj.client.Root().GetSocksByName(ctx, l.Name)
	return
}

// AddInventory calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootSockShop) AddInventory(ctx context.Context,
	objToCreate *baserootsockshopcomv1.Socks) (result *RootSocks, err error) {
	log.Debugf("[AddInventory] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["sockshops.root.sockshop.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["sockshops.root.sockshop.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Root().CreateSocksByName(ctx, objToCreate)
	log.Debugf("[AddInventory] Socks created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Root().GetSockShopByName(ctx, obj.GetName())
	if getErr == nil {
		obj.SockShop = updatedObj.SockShop
	}
	log.Debugf("[AddInventory] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteInventory calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RootSockShop) DeleteInventory(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteInventory] Received for Socks object: %s to delete", displayName)
	l, ok := obj.Spec.InventoryGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Root.SockShop", "Inventory", displayName)
	}
	err = obj.client.Root().DeleteSocksByName(ctx, l.Name)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteInventory] Socks object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Root().GetSockShopByName(ctx, obj.GetName())
	if err == nil {
		obj.SockShop = updatedObj.SockShop
	}
	return
}

type RootSockShopPO struct {
	client *Clientset
	PO     []baserootsockshopcomv1.Child
}

func (n *RootSockShopPO) Next(ctx context.Context) (*RootOrders, error) {
	for index, child := range n.PO {
		obj, err := n.client.Root().GetOrdersByName(ctx, child.Name)
		if err == nil {
			if index == len(n.PO)-1 {
				n.PO = nil
			} else {
				n.PO = n.PO[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllPOIter returns an iterator for all children of given type
func (obj *RootSockShop) GetAllPOIter(ctx context.Context) (
	result RootSockShopPO) {
	result.client = obj.client
	result.PO = make([]baserootsockshopcomv1.Child, 0, len(obj.Spec.POGvk))
	for _, v := range obj.Spec.POGvk {
		result.PO = append(result.PO, v)
	}
	return
}

// GetAllPO returns all children of a given type
func (obj *RootSockShop) GetAllPO(ctx context.Context) (
	result []*RootOrders, err error) {
	result = make([]*RootOrders, 0, len(obj.Spec.POGvk))
	for _, v := range obj.Spec.POGvk {
		l, err := obj.client.Root().GetOrdersByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetPO returns child which has given displayName
func (obj *RootSockShop) GetPO(ctx context.Context,
	displayName string) (result *RootOrders, err error) {
	l, ok := obj.Spec.POGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Root.SockShop", "PO", displayName)
	}
	result, err = obj.client.Root().GetOrdersByName(ctx, l.Name)
	return
}

// AddPO calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootSockShop) AddPO(ctx context.Context,
	objToCreate *baserootsockshopcomv1.Orders) (result *RootOrders, err error) {
	log.Debugf("[AddPO] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["sockshops.root.sockshop.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["sockshops.root.sockshop.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Root().CreateOrdersByName(ctx, objToCreate)
	log.Debugf("[AddPO] Orders created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Root().GetSockShopByName(ctx, obj.GetName())
	if getErr == nil {
		obj.SockShop = updatedObj.SockShop
	}
	log.Debugf("[AddPO] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeletePO calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RootSockShop) DeletePO(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeletePO] Received for Orders object: %s to delete", displayName)
	l, ok := obj.Spec.POGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Root.SockShop", "PO", displayName)
	}
	err = obj.client.Root().DeleteOrdersByName(ctx, l.Name)
	if err != nil {
		return err
	}
	log.Debugf("[ DeletePO] Orders object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Root().GetSockShopByName(ctx, obj.GetName())
	if err == nil {
		obj.SockShop = updatedObj.SockShop
	}
	return
}

type RootSockShopShippingLedger struct {
	client         *Clientset
	ShippingLedger []baserootsockshopcomv1.Child
}

func (n *RootSockShopShippingLedger) Next(ctx context.Context) (*RootShipping, error) {
	for index, child := range n.ShippingLedger {
		obj, err := n.client.Root().GetShippingByName(ctx, child.Name)
		if err == nil {
			if index == len(n.ShippingLedger)-1 {
				n.ShippingLedger = nil
			} else {
				n.ShippingLedger = n.ShippingLedger[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllShippingLedgerIter returns an iterator for all children of given type
func (obj *RootSockShop) GetAllShippingLedgerIter(ctx context.Context) (
	result RootSockShopShippingLedger) {
	result.client = obj.client
	result.ShippingLedger = make([]baserootsockshopcomv1.Child, 0, len(obj.Spec.ShippingLedgerGvk))
	for _, v := range obj.Spec.ShippingLedgerGvk {
		result.ShippingLedger = append(result.ShippingLedger, v)
	}
	return
}

// GetAllShippingLedger returns all children of a given type
func (obj *RootSockShop) GetAllShippingLedger(ctx context.Context) (
	result []*RootShipping, err error) {
	result = make([]*RootShipping, 0, len(obj.Spec.ShippingLedgerGvk))
	for _, v := range obj.Spec.ShippingLedgerGvk {
		l, err := obj.client.Root().GetShippingByName(ctx, v.Name)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetShippingLedger returns child which has given displayName
func (obj *RootSockShop) GetShippingLedger(ctx context.Context,
	displayName string) (result *RootShipping, err error) {
	l, ok := obj.Spec.ShippingLedgerGvk[displayName]
	if !ok {
		return nil, NewChildNotFound(obj.DisplayName(), "Root.SockShop", "ShippingLedger", displayName)
	}
	result, err = obj.client.Root().GetShippingByName(ctx, l.Name)
	return
}

// AddShippingLedger calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootSockShop) AddShippingLedger(ctx context.Context,
	objToCreate *baserootsockshopcomv1.Shipping) (result *RootShipping, err error) {
	log.Debugf("[AddShippingLedger] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["sockshops.root.sockshop.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["sockshops.root.sockshop.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Root().CreateShippingByName(ctx, objToCreate)
	log.Debugf("[AddShippingLedger] Shipping created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Root().GetSockShopByName(ctx, obj.GetName())
	if getErr == nil {
		obj.SockShop = updatedObj.SockShop
	}
	log.Debugf("[AddShippingLedger] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteShippingLedger calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RootSockShop) DeleteShippingLedger(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteShippingLedger] Received for Shipping object: %s to delete", displayName)
	l, ok := obj.Spec.ShippingLedgerGvk[displayName]
	if !ok {
		return NewChildNotFound(obj.DisplayName(), "Root.SockShop", "ShippingLedger", displayName)
	}
	err = obj.client.Root().DeleteShippingByName(ctx, l.Name)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteShippingLedger] Shipping object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Root().GetSockShopByName(ctx, obj.GetName())
	if err == nil {
		obj.SockShop = updatedObj.SockShop
	}
	return
}

type sockshopRootSockshopV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *sockshopRootSockshopV1Chainer) Subscribe() {
	key := "sockshops.root.sockshop.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootsockshopcomv1.NewSockShopInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *sockshopRootSockshopV1Chainer) Unsubscribe() {
	key := "sockshops.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *sockshopRootSockshopV1Chainer) IsSubscribed() bool {
	key := "sockshops.root.sockshop.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *sockshopRootSockshopV1Chainer) RegisterEventHandler(addCB func(obj *RootSockShop), updateCB func(oldObj, newObj *RootSockShop), deleteCB func(obj *RootSockShop)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RootSockShop")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "sockshops.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootSockShop")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootSockShop, so creating a new one")
		informer = informerrootsockshopcomv1.NewSockShopInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RootSockShop{
				client:   c.client,
				SockShop: obj.(*baserootsockshopcomv1.SockShop),
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RootSockShop{
				client:   c.client,
				SockShop: oldObj.(*baserootsockshopcomv1.SockShop),
			}
			newData := &RootSockShop{
				client:   c.client,
				SockShop: newObj.(*baserootsockshopcomv1.SockShop),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RootSockShop{
				client:   c.client,
				SockShop: obj.(*baserootsockshopcomv1.SockShop),
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *sockshopRootSockshopV1Chainer) RegisterAddCallback(cbfn func(obj *RootSockShop)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RootSockShop")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "sockshops.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] RootSockShop Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootSockShop{
					client:   c.client,
					SockShop: obj.(*baserootsockshopcomv1.SockShop),
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] RootSockShop Create New Informer")
		informer := informerrootsockshopcomv1.NewSockShopInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootSockShop{
					client:   c.client,
					SockShop: obj.(*baserootsockshopcomv1.SockShop),
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *sockshopRootSockshopV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RootSockShop)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RootSockShop")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "sockshops.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] RootSockShop Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootSockShop{
					client:   c.client,
					SockShop: oldObj.(*baserootsockshopcomv1.SockShop),
				}
				newData := &RootSockShop{
					client:   c.client,
					SockShop: newObj.(*baserootsockshopcomv1.SockShop),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] RootSockShop Create New Informer")
		informer := informerrootsockshopcomv1.NewSockShopInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootSockShop{
					client:   c.client,
					SockShop: oldObj.(*baserootsockshopcomv1.SockShop),
				}
				newData := &RootSockShop{
					client:   c.client,
					SockShop: newObj.(*baserootsockshopcomv1.SockShop),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *sockshopRootSockshopV1Chainer) RegisterDeleteCallback(cbfn func(obj *RootSockShop)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RootSockShop")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "sockshops.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] RootSockShop Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootSockShop{
					client:   c.client,
					SockShop: obj.(*baserootsockshopcomv1.SockShop),
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] RootSockShop Create New Informer")
		informer := informerrootsockshopcomv1.NewSockShopInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootSockShop{
					client:   c.client,
					SockShop: obj.(*baserootsockshopcomv1.SockShop),
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *sockshopRootSockshopV1Chainer) Inventory(name string) *socksRootSockshopV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["sockses.root.sockshop.com"] = name
	return &socksRootSockshopV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetInventory calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *sockshopRootSockshopV1Chainer) GetInventory(ctx context.Context, displayName string) (result *RootSocks, err error) {
	hashedName := helper.GetHashedName("sockses.root.sockshop.com", c.parentLabels, displayName)
	return c.client.Root().GetSocksByName(ctx, hashedName)
}

// AddInventory calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *sockshopRootSockshopV1Chainer) AddInventory(ctx context.Context,
	objToCreate *baserootsockshopcomv1.Socks) (result *RootSocks, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("sockses.root.sockshop.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Root().CreateSocksByName(ctx, objToCreate)
}

// DeleteInventory calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *sockshopRootSockshopV1Chainer) DeleteInventory(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("sockses.root.sockshop.com", c.parentLabels, name)
	return c.client.Root().DeleteSocksByName(ctx, hashedName)
}

func (c *sockshopRootSockshopV1Chainer) PO(name string) *ordersRootSockshopV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["orderses.root.sockshop.com"] = name
	return &ordersRootSockshopV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetPO calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *sockshopRootSockshopV1Chainer) GetPO(ctx context.Context, displayName string) (result *RootOrders, err error) {
	hashedName := helper.GetHashedName("orderses.root.sockshop.com", c.parentLabels, displayName)
	return c.client.Root().GetOrdersByName(ctx, hashedName)
}

// AddPO calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *sockshopRootSockshopV1Chainer) AddPO(ctx context.Context,
	objToCreate *baserootsockshopcomv1.Orders) (result *RootOrders, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("orderses.root.sockshop.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Root().CreateOrdersByName(ctx, objToCreate)
}

// DeletePO calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *sockshopRootSockshopV1Chainer) DeletePO(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("orderses.root.sockshop.com", c.parentLabels, name)
	return c.client.Root().DeleteOrdersByName(ctx, hashedName)
}

func (c *sockshopRootSockshopV1Chainer) ShippingLedger(name string) *shippingRootSockshopV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["shippings.root.sockshop.com"] = name
	return &shippingRootSockshopV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetShippingLedger calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *sockshopRootSockshopV1Chainer) GetShippingLedger(ctx context.Context, displayName string) (result *RootShipping, err error) {
	hashedName := helper.GetHashedName("shippings.root.sockshop.com", c.parentLabels, displayName)
	return c.client.Root().GetShippingByName(ctx, hashedName)
}

// AddShippingLedger calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *sockshopRootSockshopV1Chainer) AddShippingLedger(ctx context.Context,
	objToCreate *baserootsockshopcomv1.Shipping) (result *RootShipping, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("shippings.root.sockshop.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Root().CreateShippingByName(ctx, objToCreate)
}

// DeleteShippingLedger calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *sockshopRootSockshopV1Chainer) DeleteShippingLedger(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("shippings.root.sockshop.com", c.parentLabels, name)
	return c.client.Root().DeleteShippingByName(ctx, hashedName)
}

// GetSocksByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) GetSocksByName(ctx context.Context, hashedName string) (*RootSocks, error) {
	key := "sockses.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetSocksByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baserootsockshopcomv1.Socks)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetSocksByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baserootsockshopcomv1.Socks).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetSocksByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RootSocks{
					client: group.client,
					Socks:  resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RootSocks{
				client: group.client,
				Socks:  resWrCache.(*baserootsockshopcomv1.Socks),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootSockshopV1().
			Sockses().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RootSocks{
				client: group.client,
				Socks:  result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetSocksByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Sockses: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetSocksByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetSocksByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadSocksByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) ForceReadSocksByName(ctx context.Context, hashedName string) (*RootSocks, error) {
	log.Debugf("[ForceReadSocksByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootSockshopV1().
			Sockses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadSocksByName] Failed to Get Sockses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Sockses: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadSocksByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadSocksByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadSocksByName] Executed Successfully :%s", hashedName)
			return &RootSocks{
				client: group.client,
				Socks:  result,
			}, nil
		}
	}
}

// DeleteSocksByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) DeleteSocksByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteSocksByName] Received objectToDelete: %s", hashedName)

	var (
		retryCount int
		result     *baserootsockshopcomv1.Socks
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			Sockses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteSocksByName] Failed to get Sockses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Sockses: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteSocksByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteSocksByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteSocksByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RootSockshopV1().
			Sockses().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteSocksByName] failed to delete Sockses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Sockses: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteSocksByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteSocksByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteSocksByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("sockses.root.sockshop.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	var gvkPresent bool
	log.Debugf("[DeleteSocksByName] Get parent details for object: %s", hashedName)
	var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["sockshops.root.sockshop.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("sockshops.root.sockshop.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("sockshops.root.sockshop.com", parents, parentName)
	}
	parentData, err := group.client.baseClient.
		RootSockshopV1().
		SockShops().Get(ctx, parentName, metav1.GetOptions{})
	if err != nil {
		log.Errorf("[DeleteSocksByName] Failed to get parent node for obj:(%s) %+v", hashedName, err)
		if errors.IsNotFound(err) {
			return nil
		} else {
			return err
		}
	}

	var displayName string
	// Iterate Parent Gvk
	for k, v := range parentData.Spec.InventoryGvk {
		if hashedName == v.Name {
			displayName = k
			log.Debugf("[DeleteSocksByName] GVK %s is present in parent for node: %s", k, hashedName)
			gvkPresent = true
		}
	}

	if gvkPresent {

		patchOp := PatchOp{
			Op:   "remove",
			Path: "/spec/inventoryGvk/" + displayName,
		}

		patch = append(patch, patchOp)
		marshaled, err := patch.Marshal()
		if err != nil {
			return err
		}

		retryCount = 0
		newCtx := context.TODO()
		for {
			_, err = group.client.baseClient.
				RootSockshopV1().
				SockShops().Patch(newCtx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
			if err != nil {
				log.Errorf("[DeleteSocksByName] Failed to patch Socks gvk in parent node[SockShops]: %+v", err)
				if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
					log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
					if retryCount == maxRetryCount {
						log.Errorf("Max retry exceed on patching gvk: %s", hashedName)
						return err
					}
					retryCount += 1
					time.Sleep(sleepTime * time.Second)
				} else if customerrors.Is(err, context.Canceled) {
					log.Errorf("[DeleteSocksByName]: context canceled: %s", hashedName)
					return context.Canceled
				} else {
					log.Errorf("[DeleteSocksByName] Object: %s unexpected error: %+v", hashedName, err)
					return err
				}
			} else {
				log.Debugf("[DeleteSocksByName] Patch Socks Success: %s", hashedName)
				break
			}
		}
		log.Debugf("[DeleteSocksByName] Executed Successfully: %s", hashedName)
	}

	return
}

// CreateSocksByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RootSockshopV1) CreateSocksByName(ctx context.Context,
	objToCreate *baserootsockshopcomv1.Socks) (*RootSocks, error) {
	log.Debugf("[CreateSocksByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baserootsockshopcomv1.Socks
		err        error
		exists     bool
		existsErr  error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			Sockses().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateSocksByName] Failed to create Socks: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Socks: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateSocksByName] context canceled while creating Socks: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateSocksByName] Socks: %s already exists, error: %+v", objToCreate.GetName(), err)
				exists = true
				existsErr = err
				break
			} else {
				log.Errorf("[CreateSocksByName] found unexpected error while creating Socks: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateSocksByName] Socks: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("sockses.root.sockshop.com"); ok {
				log.Debugf("[CreateSocksByName] Socks: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["sockshops.root.sockshop.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("sockshops.root.sockshop.com", objToCreate.GetLabels(), parentName)
	}

	if exists {
		parent, err2 := group.client.Root().GetSockShopByName(context.Background(), parentName)
		if err2 != nil {
			log.Errorf("[CreateSocksByName] Failed to get parent of Socks: %s, error: %+v", objToCreate.GetName(), err)
			return nil, err2
		}
		_, ok := parent.Spec.InventoryGvk[objToCreate.DisplayName()]
		if ok {
			return &RootSocks{
				client: group.client,
				Socks:  result,
			}, existsErr
		}
	}
	payload := "{\"spec\": {\"inventoryGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Socks\", \"group\": \"root.sockshop.com\"}}}}"

	retryCount = 0
	newCtx := context.TODO()
	for {
		_, err = group.client.baseClient.
			RootSockshopV1().
			SockShops().Patch(newCtx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
		if err != nil {
			log.Errorf("[CreateSocksByName] Failed to patch Socks gvk in parent node[SockShops] %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching gvk: %s", objToCreate.GetName())
					log.Debugf("[CreateSocksByName] Trigger Socks delete: %s", objToCreate.GetName())
					delErr := group.DeleteSocksByName(newCtx, objToCreate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Socks: %s", objToCreate.GetName())
						return nil, delErr
					}
					log.Debugf("Socks Deleted: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateSocksByName]: context canceled: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[CreateSocksByName] Object: %s unexpected error: %+v", objToCreate.GetName(), err)
				log.Debugf("Trigger Socks delete: %s", objToCreate.GetName())
				delErr := group.DeleteSocksByName(newCtx, objToCreate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Socks: %s", objToCreate.GetName())
					return nil, delErr
				}
				log.Debugf("Socks Deleted: %s", objToCreate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[CreateSocksByName] Patch Socks Success :%s", objToCreate.GetName())
			break
		}
	}

	log.Debugf("[CreateSocksByName] Executed Successfully: %s", objToCreate.GetName())
	return &RootSocks{
		client: group.client,
		Socks:  result,
	}, nil
}

// UpdateSocksByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RootSockshopV1) UpdateSocksByName(ctx context.Context,
	objToUpdate *baserootsockshopcomv1.Socks) (*RootSocks, error) {
	log.Debugf("[UpdateSocksByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Root().GetSocksByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["sockses.root.sockshop.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Brand)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Brand).IsNil() {
			patchValueBrand := objToUpdate.Spec.Brand
			patchOpBrand := PatchOp{
				Op:    "replace",
				Path:  "/spec/brand",
				Value: patchValueBrand,
			}
			patch = append(patch, patchOpBrand)
		}
	} else {
		patchValueBrand := objToUpdate.Spec.Brand
		patchOpBrand := PatchOp{
			Op:    "replace",
			Path:  "/spec/brand",
			Value: patchValueBrand,
		}
		patch = append(patch, patchOpBrand)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Color)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Color).IsNil() {
			patchValueColor := objToUpdate.Spec.Color
			patchOpColor := PatchOp{
				Op:    "replace",
				Path:  "/spec/color",
				Value: patchValueColor,
			}
			patch = append(patch, patchOpColor)
		}
	} else {
		patchValueColor := objToUpdate.Spec.Color
		patchOpColor := PatchOp{
			Op:    "replace",
			Path:  "/spec/color",
			Value: patchValueColor,
		}
		patch = append(patch, patchOpColor)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Size)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Size).IsNil() {
			patchValueSize := objToUpdate.Spec.Size
			patchOpSize := PatchOp{
				Op:    "replace",
				Path:  "/spec/size",
				Value: patchValueSize,
			}
			patch = append(patch, patchOpSize)
		}
	} else {
		patchValueSize := objToUpdate.Spec.Size
		patchOpSize := PatchOp{
			Op:    "replace",
			Path:  "/spec/size",
			Value: patchValueSize,
		}
		patch = append(patch, patchOpSize)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baserootsockshopcomv1.Socks
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			Sockses().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateSocksByName] Failed to patch Socks gvk in parent node[SockShops]: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching gvk: %s", objToUpdate.GetName())
					log.Debugf("Trigger Socks Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteSocksByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Socks: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Socks deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateSocksByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateSocksByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Socks Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteSocksByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Socks: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Socks Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateSocksByName] Patch Socks Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("sockses.root.sockshop.com"); ok {
				log.Debugf("[UpdateSocksByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateSocksByName] Executed Successfully %s", objToUpdate.GetName())
	return &RootSocks{
		client: group.client,
		Socks:  result,
	}, nil
}

// ListSockses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RootSockshopV1) ListSockses(ctx context.Context,
	opts metav1.ListOptions) (result []*RootSocks, err error) {
	key := "sockses.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RootSocks, len(items))
		for k, v := range items {
			item, _ := v.(*baserootsockshopcomv1.Socks)
			result[k] = &RootSocks{
				client: group.client,
				Socks:  item,
			}
		}
	} else {
		list, err := group.client.baseClient.RootSockshopV1().
			Sockses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RootSocks, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RootSocks{
				client: group.client,
				Socks:  &item,
			}
		}
	}
	return
}

type RootSocks struct {
	client *Clientset
	*baserootsockshopcomv1.Socks
}

// Delete removes obj and all it's children from the database.
func (obj *RootSocks) Delete(ctx context.Context) error {
	err := obj.client.Root().DeleteSocksByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Socks = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RootSocks) Update(ctx context.Context) error {
	result, err := obj.client.Root().UpdateSocksByName(ctx, obj.Socks)
	if err != nil {
		return err
	}
	obj.Socks = result.Socks
	return nil
}

func (obj *RootSocks) GetParent(ctx context.Context) (result *RootSockShop, err error) {
	hashedName := helper.GetHashedName("sockshops.root.sockshop.com", obj.Labels, obj.Labels["sockshops.root.sockshop.com"])
	return obj.client.Root().GetSockShopByName(ctx, hashedName)
}

type socksRootSockshopV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *socksRootSockshopV1Chainer) Subscribe() {
	key := "sockses.root.sockshop.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootsockshopcomv1.NewSocksInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *socksRootSockshopV1Chainer) Unsubscribe() {
	key := "sockses.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *socksRootSockshopV1Chainer) IsSubscribed() bool {
	key := "sockses.root.sockshop.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *socksRootSockshopV1Chainer) RegisterEventHandler(addCB func(obj *RootSocks), updateCB func(oldObj, newObj *RootSocks), deleteCB func(obj *RootSocks)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RootSocks")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "sockses.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootSocks")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootSocks, so creating a new one")
		informer = informerrootsockshopcomv1.NewSocksInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RootSocks{
				client: c.client,
				Socks:  obj.(*baserootsockshopcomv1.Socks),
			}

			var parent *RootSockShop
			gvkExist := false
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				// Check GVK

				if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; !ok {
					time.Sleep(500 * time.Millisecond)
					continue
				}

				gvkExist = true
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
				parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !gvkExist {
				// Check GVK

				if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; !ok {
					return
				}

				panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RootSocks{
				client: c.client,
				Socks:  oldObj.(*baserootsockshopcomv1.Socks),
			}
			newData := &RootSocks{
				client: c.client,
				Socks:  newObj.(*baserootsockshopcomv1.Socks),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RootSocks{
				client: c.client,
				Socks:  obj.(*baserootsockshopcomv1.Socks),
			}

			var parent *RootSockShop
			gvkExist := true
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				// Check GVK

				if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; ok {
					time.Sleep(500 * time.Millisecond)
					continue
				}

				gvkExist = false
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
				parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if gvkExist {
				// Check GVK

				if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; ok {
					return
				}

				panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *socksRootSockshopV1Chainer) RegisterAddCallback(cbfn func(obj *RootSocks)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RootSocks")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "sockses.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] RootSocks Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootSocks{
					client: c.client,
					Socks:  obj.(*baserootsockshopcomv1.Socks),
				}

				var parent *RootSockShop
				gvkExist := false
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; !ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = true

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if !gvkExist {
					// Check GVK

					if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; !ok {
						return
					}

					panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] RootSocks Create New Informer")
		informer := informerrootsockshopcomv1.NewSocksInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootSocks{
					client: c.client,
					Socks:  obj.(*baserootsockshopcomv1.Socks),
				}

				var parent *RootSockShop
				gvkExist := false
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; !ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = true

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if !gvkExist {
					// Check GVK

					if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; !ok {
						return
					}

					panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *socksRootSockshopV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RootSocks)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RootSocks")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "sockses.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] RootSocks Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootSocks{
					client: c.client,
					Socks:  oldObj.(*baserootsockshopcomv1.Socks),
				}
				newData := &RootSocks{
					client: c.client,
					Socks:  newObj.(*baserootsockshopcomv1.Socks),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] RootSocks Create New Informer")
		informer := informerrootsockshopcomv1.NewSocksInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootSocks{
					client: c.client,
					Socks:  oldObj.(*baserootsockshopcomv1.Socks),
				}
				newData := &RootSocks{
					client: c.client,
					Socks:  newObj.(*baserootsockshopcomv1.Socks),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *socksRootSockshopV1Chainer) RegisterDeleteCallback(cbfn func(obj *RootSocks)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RootSocks")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "sockses.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] RootSocks Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootSocks{
					client: c.client,
					Socks:  obj.(*baserootsockshopcomv1.Socks),
				}

				var parent *RootSockShop
				gvkExist := true
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = false
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if gvkExist {
					// Check GVK

					if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; ok {
						return
					}

					panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] RootSocks Create New Informer")
		informer := informerrootsockshopcomv1.NewSocksInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootSocks{
					client: c.client,
					Socks:  obj.(*baserootsockshopcomv1.Socks),
				}

				var parent *RootSockShop
				gvkExist := true
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = false

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if gvkExist {
					// Check GVK

					if _, ok := parent.Spec.InventoryGvk[nc.DisplayName()]; ok {
						return
					}

					panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

// GetOrdersByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) GetOrdersByName(ctx context.Context, hashedName string) (*RootOrders, error) {
	key := "orderses.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetOrdersByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baserootsockshopcomv1.Orders)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetOrdersByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baserootsockshopcomv1.Orders).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetOrdersByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RootOrders{
					client: group.client,
					Orders: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RootOrders{
				client: group.client,
				Orders: resWrCache.(*baserootsockshopcomv1.Orders),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootSockshopV1().
			Orderses().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RootOrders{
				client: group.client,
				Orders: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetOrdersByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Orderses: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetOrdersByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetOrdersByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadOrdersByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) ForceReadOrdersByName(ctx context.Context, hashedName string) (*RootOrders, error) {
	log.Debugf("[ForceReadOrdersByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootSockshopV1().
			Orderses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadOrdersByName] Failed to Get Orderses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Orderses: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadOrdersByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadOrdersByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadOrdersByName] Executed Successfully :%s", hashedName)
			return &RootOrders{
				client: group.client,
				Orders: result,
			}, nil
		}
	}
}

// DeleteOrdersByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) DeleteOrdersByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteOrdersByName] Received objectToDelete: %s", hashedName)

	var (
		retryCount int
		result     *baserootsockshopcomv1.Orders
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			Orderses().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteOrdersByName] Failed to get Orderses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Orderses: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteOrdersByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteOrdersByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteOrdersByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RootSockshopV1().
			Orderses().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteOrdersByName] failed to delete Orderses: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Orderses: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteOrdersByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteOrdersByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteOrdersByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("orderses.root.sockshop.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	var gvkPresent bool
	log.Debugf("[DeleteOrdersByName] Get parent details for object: %s", hashedName)
	var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["sockshops.root.sockshop.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("sockshops.root.sockshop.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("sockshops.root.sockshop.com", parents, parentName)
	}
	parentData, err := group.client.baseClient.
		RootSockshopV1().
		SockShops().Get(ctx, parentName, metav1.GetOptions{})
	if err != nil {
		log.Errorf("[DeleteOrdersByName] Failed to get parent node for obj:(%s) %+v", hashedName, err)
		if errors.IsNotFound(err) {
			return nil
		} else {
			return err
		}
	}

	var displayName string
	// Iterate Parent Gvk
	for k, v := range parentData.Spec.POGvk {
		if hashedName == v.Name {
			displayName = k
			log.Debugf("[DeleteOrdersByName] GVK %s is present in parent for node: %s", k, hashedName)
			gvkPresent = true
		}
	}

	if gvkPresent {

		patchOp := PatchOp{
			Op:   "remove",
			Path: "/spec/pOGvk/" + displayName,
		}

		patch = append(patch, patchOp)
		marshaled, err := patch.Marshal()
		if err != nil {
			return err
		}

		retryCount = 0
		newCtx := context.TODO()
		for {
			_, err = group.client.baseClient.
				RootSockshopV1().
				SockShops().Patch(newCtx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
			if err != nil {
				log.Errorf("[DeleteOrdersByName] Failed to patch Orders gvk in parent node[SockShops]: %+v", err)
				if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
					log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
					if retryCount == maxRetryCount {
						log.Errorf("Max retry exceed on patching gvk: %s", hashedName)
						return err
					}
					retryCount += 1
					time.Sleep(sleepTime * time.Second)
				} else if customerrors.Is(err, context.Canceled) {
					log.Errorf("[DeleteOrdersByName]: context canceled: %s", hashedName)
					return context.Canceled
				} else {
					log.Errorf("[DeleteOrdersByName] Object: %s unexpected error: %+v", hashedName, err)
					return err
				}
			} else {
				log.Debugf("[DeleteOrdersByName] Patch Orders Success: %s", hashedName)
				break
			}
		}
		log.Debugf("[DeleteOrdersByName] Executed Successfully: %s", hashedName)
	}

	return
}

// CreateOrdersByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RootSockshopV1) CreateOrdersByName(ctx context.Context,
	objToCreate *baserootsockshopcomv1.Orders) (*RootOrders, error) {
	log.Debugf("[CreateOrdersByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.CartGvk = nil
	objToCreate.Spec.ShippingGvk = nil

	var (
		retryCount int
		result     *baserootsockshopcomv1.Orders
		err        error
		exists     bool
		existsErr  error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			Orderses().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateOrdersByName] Failed to create Orders: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Orders: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateOrdersByName] context canceled while creating Orders: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateOrdersByName] Orders: %s already exists, error: %+v", objToCreate.GetName(), err)
				exists = true
				existsErr = err
				break
			} else {
				log.Errorf("[CreateOrdersByName] found unexpected error while creating Orders: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateOrdersByName] Orders: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("orderses.root.sockshop.com"); ok {
				log.Debugf("[CreateOrdersByName] Orders: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["sockshops.root.sockshop.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("sockshops.root.sockshop.com", objToCreate.GetLabels(), parentName)
	}

	if exists {
		parent, err2 := group.client.Root().GetSockShopByName(context.Background(), parentName)
		if err2 != nil {
			log.Errorf("[CreateOrdersByName] Failed to get parent of Orders: %s, error: %+v", objToCreate.GetName(), err)
			return nil, err2
		}
		_, ok := parent.Spec.POGvk[objToCreate.DisplayName()]
		if ok {
			return &RootOrders{
				client: group.client,
				Orders: result,
			}, existsErr
		}
	}
	payload := "{\"spec\": {\"pOGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Orders\", \"group\": \"root.sockshop.com\"}}}}"

	retryCount = 0
	newCtx := context.TODO()
	for {
		_, err = group.client.baseClient.
			RootSockshopV1().
			SockShops().Patch(newCtx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
		if err != nil {
			log.Errorf("[CreateOrdersByName] Failed to patch Orders gvk in parent node[SockShops] %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching gvk: %s", objToCreate.GetName())
					log.Debugf("[CreateOrdersByName] Trigger Orders delete: %s", objToCreate.GetName())
					delErr := group.DeleteOrdersByName(newCtx, objToCreate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Orders: %s", objToCreate.GetName())
						return nil, delErr
					}
					log.Debugf("Orders Deleted: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateOrdersByName]: context canceled: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[CreateOrdersByName] Object: %s unexpected error: %+v", objToCreate.GetName(), err)
				log.Debugf("Trigger Orders delete: %s", objToCreate.GetName())
				delErr := group.DeleteOrdersByName(newCtx, objToCreate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Orders: %s", objToCreate.GetName())
					return nil, delErr
				}
				log.Debugf("Orders Deleted: %s", objToCreate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[CreateOrdersByName] Patch Orders Success :%s", objToCreate.GetName())
			break
		}
	}

	log.Debugf("[CreateOrdersByName] Executed Successfully: %s", objToCreate.GetName())
	return &RootOrders{
		client: group.client,
		Orders: result,
	}, nil
}

// UpdateOrdersByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RootSockshopV1) UpdateOrdersByName(ctx context.Context,
	objToUpdate *baserootsockshopcomv1.Orders) (*RootOrders, error) {
	log.Debugf("[UpdateOrdersByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Root().GetOrdersByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["orderses.root.sockshop.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.SockName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.SockName).IsNil() {
			patchValueSockName := objToUpdate.Spec.SockName
			patchOpSockName := PatchOp{
				Op:    "replace",
				Path:  "/spec/sockName",
				Value: patchValueSockName,
			}
			patch = append(patch, patchOpSockName)
		}
	} else {
		patchValueSockName := objToUpdate.Spec.SockName
		patchOpSockName := PatchOp{
			Op:    "replace",
			Path:  "/spec/sockName",
			Value: patchValueSockName,
		}
		patch = append(patch, patchOpSockName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Address)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Address).IsNil() {
			patchValueAddress := objToUpdate.Spec.Address
			patchOpAddress := PatchOp{
				Op:    "replace",
				Path:  "/spec/address",
				Value: patchValueAddress,
			}
			patch = append(patch, patchOpAddress)
		}
	} else {
		patchValueAddress := objToUpdate.Spec.Address
		patchOpAddress := PatchOp{
			Op:    "replace",
			Path:  "/spec/address",
			Value: patchValueAddress,
		}
		patch = append(patch, patchOpAddress)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baserootsockshopcomv1.Orders
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			Orderses().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateOrdersByName] Failed to patch Orders gvk in parent node[SockShops]: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching gvk: %s", objToUpdate.GetName())
					log.Debugf("Trigger Orders Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteOrdersByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Orders: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Orders deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateOrdersByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateOrdersByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Orders Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteOrdersByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Orders: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Orders Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateOrdersByName] Patch Orders Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("orderses.root.sockshop.com"); ok {
				log.Debugf("[UpdateOrdersByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateOrdersByName] Executed Successfully %s", objToUpdate.GetName())
	return &RootOrders{
		client: group.client,
		Orders: result,
	}, nil
}

// ListOrderses returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RootSockshopV1) ListOrderses(ctx context.Context,
	opts metav1.ListOptions) (result []*RootOrders, err error) {
	key := "orderses.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RootOrders, len(items))
		for k, v := range items {
			item, _ := v.(*baserootsockshopcomv1.Orders)
			result[k] = &RootOrders{
				client: group.client,
				Orders: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RootSockshopV1().
			Orderses().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RootOrders, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RootOrders{
				client: group.client,
				Orders: &item,
			}
		}
	}
	return
}

type RootOrders struct {
	client *Clientset
	*baserootsockshopcomv1.Orders
}

// Delete removes obj and all it's children from the database.
func (obj *RootOrders) Delete(ctx context.Context) error {
	err := obj.client.Root().DeleteOrdersByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Orders = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RootOrders) Update(ctx context.Context) error {
	result, err := obj.client.Root().UpdateOrdersByName(ctx, obj.Orders)
	if err != nil {
		return err
	}
	obj.Orders = result.Orders
	return nil
}

func (obj *RootOrders) GetParent(ctx context.Context) (result *RootSockShop, err error) {
	hashedName := helper.GetHashedName("sockshops.root.sockshop.com", obj.Labels, obj.Labels["sockshops.root.sockshop.com"])
	return obj.client.Root().GetSockShopByName(ctx, hashedName)
}

// GetCart returns link of given type
func (obj *RootOrders) GetCart(ctx context.Context) (
	result *RootSocks, err error) {
	if obj.Spec.CartGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Root.Orders", "Cart")
	}
	return obj.client.Root().GetSocksByName(ctx, obj.Spec.CartGvk.Name)
}

// LinkCart links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *RootOrders) LinkCart(ctx context.Context,
	linkToAdd *RootSocks) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/cartGvk",
		Value: baserootsockshopcomv1.Child{
			Group: "root.sockshop.com",
			Kind:  "Socks",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.RootSockshopV1().Orderses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Orders = result
	return nil
}

// UnlinkCart unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *RootOrders) UnlinkCart(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/cartGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.RootSockshopV1().Orderses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Orders = result
	return nil

}

// GetShipping returns link of given type
func (obj *RootOrders) GetShipping(ctx context.Context) (
	result *RootShipping, err error) {
	if obj.Spec.ShippingGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Root.Orders", "Shipping")
	}
	return obj.client.Root().GetShippingByName(ctx, obj.Spec.ShippingGvk.Name)
}

// LinkShipping links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *RootOrders) LinkShipping(ctx context.Context,
	linkToAdd *RootShipping) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/shippingGvk",
		Value: baserootsockshopcomv1.Child{
			Group: "root.sockshop.com",
			Kind:  "Shipping",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.RootSockshopV1().Orderses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Orders = result
	return nil
}

// UnlinkShipping unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *RootOrders) UnlinkShipping(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/shippingGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.RootSockshopV1().Orderses().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Orders = result
	return nil

}

type ordersRootSockshopV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *ordersRootSockshopV1Chainer) Subscribe() {
	key := "orderses.root.sockshop.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootsockshopcomv1.NewOrdersInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *ordersRootSockshopV1Chainer) Unsubscribe() {
	key := "orderses.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *ordersRootSockshopV1Chainer) IsSubscribed() bool {
	key := "orderses.root.sockshop.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *ordersRootSockshopV1Chainer) RegisterEventHandler(addCB func(obj *RootOrders), updateCB func(oldObj, newObj *RootOrders), deleteCB func(obj *RootOrders)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RootOrders")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "orderses.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootOrders")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootOrders, so creating a new one")
		informer = informerrootsockshopcomv1.NewOrdersInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RootOrders{
				client: c.client,
				Orders: obj.(*baserootsockshopcomv1.Orders),
			}

			var parent *RootSockShop
			gvkExist := false
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				// Check GVK

				if _, ok := parent.Spec.POGvk[nc.DisplayName()]; !ok {
					time.Sleep(500 * time.Millisecond)
					continue
				}

				gvkExist = true
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
				parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !gvkExist {
				// Check GVK

				if _, ok := parent.Spec.POGvk[nc.DisplayName()]; !ok {
					return
				}

				panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RootOrders{
				client: c.client,
				Orders: oldObj.(*baserootsockshopcomv1.Orders),
			}
			newData := &RootOrders{
				client: c.client,
				Orders: newObj.(*baserootsockshopcomv1.Orders),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RootOrders{
				client: c.client,
				Orders: obj.(*baserootsockshopcomv1.Orders),
			}

			var parent *RootSockShop
			gvkExist := true
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				// Check GVK

				if _, ok := parent.Spec.POGvk[nc.DisplayName()]; ok {
					time.Sleep(500 * time.Millisecond)
					continue
				}

				gvkExist = false
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
				parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if gvkExist {
				// Check GVK

				if _, ok := parent.Spec.POGvk[nc.DisplayName()]; ok {
					return
				}

				panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *ordersRootSockshopV1Chainer) RegisterAddCallback(cbfn func(obj *RootOrders)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RootOrders")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "orderses.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] RootOrders Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootOrders{
					client: c.client,
					Orders: obj.(*baserootsockshopcomv1.Orders),
				}

				var parent *RootSockShop
				gvkExist := false
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.POGvk[nc.DisplayName()]; !ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = true

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if !gvkExist {
					// Check GVK

					if _, ok := parent.Spec.POGvk[nc.DisplayName()]; !ok {
						return
					}

					panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] RootOrders Create New Informer")
		informer := informerrootsockshopcomv1.NewOrdersInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootOrders{
					client: c.client,
					Orders: obj.(*baserootsockshopcomv1.Orders),
				}

				var parent *RootSockShop
				gvkExist := false
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.POGvk[nc.DisplayName()]; !ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = true

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if !gvkExist {
					// Check GVK

					if _, ok := parent.Spec.POGvk[nc.DisplayName()]; !ok {
						return
					}

					panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *ordersRootSockshopV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RootOrders)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RootOrders")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "orderses.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] RootOrders Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootOrders{
					client: c.client,
					Orders: oldObj.(*baserootsockshopcomv1.Orders),
				}
				newData := &RootOrders{
					client: c.client,
					Orders: newObj.(*baserootsockshopcomv1.Orders),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] RootOrders Create New Informer")
		informer := informerrootsockshopcomv1.NewOrdersInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootOrders{
					client: c.client,
					Orders: oldObj.(*baserootsockshopcomv1.Orders),
				}
				newData := &RootOrders{
					client: c.client,
					Orders: newObj.(*baserootsockshopcomv1.Orders),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *ordersRootSockshopV1Chainer) RegisterDeleteCallback(cbfn func(obj *RootOrders)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RootOrders")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "orderses.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] RootOrders Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootOrders{
					client: c.client,
					Orders: obj.(*baserootsockshopcomv1.Orders),
				}

				var parent *RootSockShop
				gvkExist := true
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.POGvk[nc.DisplayName()]; ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = false
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if gvkExist {
					// Check GVK

					if _, ok := parent.Spec.POGvk[nc.DisplayName()]; ok {
						return
					}

					panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] RootOrders Create New Informer")
		informer := informerrootsockshopcomv1.NewOrdersInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootOrders{
					client: c.client,
					Orders: obj.(*baserootsockshopcomv1.Orders),
				}

				var parent *RootSockShop
				gvkExist := true
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.POGvk[nc.DisplayName()]; ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = false

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if gvkExist {
					// Check GVK

					if _, ok := parent.Spec.POGvk[nc.DisplayName()]; ok {
						return
					}

					panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

// GetShippingByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) GetShippingByName(ctx context.Context, hashedName string) (*RootShipping, error) {
	key := "shippings.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetShippingByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baserootsockshopcomv1.Shipping)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetShippingByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baserootsockshopcomv1.Shipping).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetShippingByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RootShipping{
					client:   group.client,
					Shipping: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RootShipping{
				client:   group.client,
				Shipping: resWrCache.(*baserootsockshopcomv1.Shipping),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootSockshopV1().
			Shippings().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RootShipping{
				client:   group.client,
				Shipping: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetShippingByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Shippings: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetShippingByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetShippingByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadShippingByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) ForceReadShippingByName(ctx context.Context, hashedName string) (*RootShipping, error) {
	log.Debugf("[ForceReadShippingByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootSockshopV1().
			Shippings().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadShippingByName] Failed to Get Shippings: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Shippings: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadShippingByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadShippingByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadShippingByName] Executed Successfully :%s", hashedName)
			return &RootShipping{
				client:   group.client,
				Shipping: result,
			}, nil
		}
	}
}

// DeleteShippingByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RootSockshopV1) DeleteShippingByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteShippingByName] Received objectToDelete: %s", hashedName)

	var (
		retryCount int
		result     *baserootsockshopcomv1.Shipping
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			Shippings().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteShippingByName] Failed to get Shippings: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Shippings: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteShippingByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteShippingByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteShippingByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RootSockshopV1().
			Shippings().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteShippingByName] failed to delete Shippings: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Shippings: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteShippingByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteShippingByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteShippingByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("shippings.root.sockshop.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	var gvkPresent bool
	log.Debugf("[DeleteShippingByName] Get parent details for object: %s", hashedName)
	var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["sockshops.root.sockshop.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("sockshops.root.sockshop.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("sockshops.root.sockshop.com", parents, parentName)
	}
	parentData, err := group.client.baseClient.
		RootSockshopV1().
		SockShops().Get(ctx, parentName, metav1.GetOptions{})
	if err != nil {
		log.Errorf("[DeleteShippingByName] Failed to get parent node for obj:(%s) %+v", hashedName, err)
		if errors.IsNotFound(err) {
			return nil
		} else {
			return err
		}
	}

	var displayName string
	// Iterate Parent Gvk
	for k, v := range parentData.Spec.ShippingLedgerGvk {
		if hashedName == v.Name {
			displayName = k
			log.Debugf("[DeleteShippingByName] GVK %s is present in parent for node: %s", k, hashedName)
			gvkPresent = true
		}
	}

	if gvkPresent {

		patchOp := PatchOp{
			Op:   "remove",
			Path: "/spec/shippingLedgerGvk/" + displayName,
		}

		patch = append(patch, patchOp)
		marshaled, err := patch.Marshal()
		if err != nil {
			return err
		}

		retryCount = 0
		newCtx := context.TODO()
		for {
			_, err = group.client.baseClient.
				RootSockshopV1().
				SockShops().Patch(newCtx, parentName, types.JSONPatchType, marshaled, metav1.PatchOptions{})
			if err != nil {
				log.Errorf("[DeleteShippingByName] Failed to patch Shipping gvk in parent node[SockShops]: %+v", err)
				if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
					log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
					if retryCount == maxRetryCount {
						log.Errorf("Max retry exceed on patching gvk: %s", hashedName)
						return err
					}
					retryCount += 1
					time.Sleep(sleepTime * time.Second)
				} else if customerrors.Is(err, context.Canceled) {
					log.Errorf("[DeleteShippingByName]: context canceled: %s", hashedName)
					return context.Canceled
				} else {
					log.Errorf("[DeleteShippingByName] Object: %s unexpected error: %+v", hashedName, err)
					return err
				}
			} else {
				log.Debugf("[DeleteShippingByName] Patch Shipping Success: %s", hashedName)
				break
			}
		}
		log.Debugf("[DeleteShippingByName] Executed Successfully: %s", hashedName)
	}

	return
}

// CreateShippingByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RootSockshopV1) CreateShippingByName(ctx context.Context,
	objToCreate *baserootsockshopcomv1.Shipping) (*RootShipping, error) {
	log.Debugf("[CreateShippingByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baserootsockshopcomv1.Shipping
		err        error
		exists     bool
		existsErr  error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			Shippings().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateShippingByName] Failed to create Shipping: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Shipping: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateShippingByName] context canceled while creating Shipping: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateShippingByName] Shipping: %s already exists, error: %+v", objToCreate.GetName(), err)
				exists = true
				existsErr = err
				break
			} else {
				log.Errorf("[CreateShippingByName] found unexpected error while creating Shipping: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateShippingByName] Shipping: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("shippings.root.sockshop.com"); ok {
				log.Debugf("[CreateShippingByName] Shipping: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["sockshops.root.sockshop.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] == "true" {
		parentName = helper.GetHashedName("sockshops.root.sockshop.com", objToCreate.GetLabels(), parentName)
	}

	if exists {
		parent, err2 := group.client.Root().GetSockShopByName(context.Background(), parentName)
		if err2 != nil {
			log.Errorf("[CreateShippingByName] Failed to get parent of Shipping: %s, error: %+v", objToCreate.GetName(), err)
			return nil, err2
		}
		_, ok := parent.Spec.ShippingLedgerGvk[objToCreate.DisplayName()]
		if ok {
			return &RootShipping{
				client:   group.client,
				Shipping: result,
			}, existsErr
		}
	}
	payload := "{\"spec\": {\"shippingLedgerGvk\": {\"" + objToCreate.DisplayName() + "\": {\"name\": \"" + objToCreate.Name + "\",\"kind\": \"Shipping\", \"group\": \"root.sockshop.com\"}}}}"

	retryCount = 0
	newCtx := context.TODO()
	for {
		_, err = group.client.baseClient.
			RootSockshopV1().
			SockShops().Patch(newCtx, parentName, types.MergePatchType, []byte(payload), metav1.PatchOptions{})
		if err != nil {
			log.Errorf("[CreateShippingByName] Failed to patch Shipping gvk in parent node[SockShops] %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching gvk: %s", objToCreate.GetName())
					log.Debugf("[CreateShippingByName] Trigger Shipping delete: %s", objToCreate.GetName())
					delErr := group.DeleteShippingByName(newCtx, objToCreate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Shipping: %s", objToCreate.GetName())
						return nil, delErr
					}
					log.Debugf("Shipping Deleted: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateShippingByName]: context canceled: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[CreateShippingByName] Object: %s unexpected error: %+v", objToCreate.GetName(), err)
				log.Debugf("Trigger Shipping delete: %s", objToCreate.GetName())
				delErr := group.DeleteShippingByName(newCtx, objToCreate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Shipping: %s", objToCreate.GetName())
					return nil, delErr
				}
				log.Debugf("Shipping Deleted: %s", objToCreate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[CreateShippingByName] Patch Shipping Success :%s", objToCreate.GetName())
			break
		}
	}

	log.Debugf("[CreateShippingByName] Executed Successfully: %s", objToCreate.GetName())
	return &RootShipping{
		client:   group.client,
		Shipping: result,
	}, nil
}

// UpdateShippingByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RootSockshopV1) UpdateShippingByName(ctx context.Context,
	objToUpdate *baserootsockshopcomv1.Shipping) (*RootShipping, error) {
	log.Debugf("[UpdateShippingByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Root().GetShippingByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["shippings.root.sockshop.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.TrackingId)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.TrackingId).IsNil() {
			patchValueTrackingId := objToUpdate.Spec.TrackingId
			patchOpTrackingId := PatchOp{
				Op:    "replace",
				Path:  "/spec/trackingId",
				Value: patchValueTrackingId,
			}
			patch = append(patch, patchOpTrackingId)
		}
	} else {
		patchValueTrackingId := objToUpdate.Spec.TrackingId
		patchOpTrackingId := PatchOp{
			Op:    "replace",
			Path:  "/spec/trackingId",
			Value: patchValueTrackingId,
		}
		patch = append(patch, patchOpTrackingId)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baserootsockshopcomv1.Shipping
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RootSockshopV1().
			Shippings().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateShippingByName] Failed to patch Shipping gvk in parent node[SockShops]: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching gvk: %s", objToUpdate.GetName())
					log.Debugf("Trigger Shipping Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteShippingByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Shipping: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Shipping deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateShippingByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateShippingByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Shipping Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteShippingByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Shipping: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Shipping Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateShippingByName] Patch Shipping Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("shippings.root.sockshop.com"); ok {
				log.Debugf("[UpdateShippingByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateShippingByName] Executed Successfully %s", objToUpdate.GetName())
	return &RootShipping{
		client:   group.client,
		Shipping: result,
	}, nil
}

// ListShippings returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RootSockshopV1) ListShippings(ctx context.Context,
	opts metav1.ListOptions) (result []*RootShipping, err error) {
	key := "shippings.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RootShipping, len(items))
		for k, v := range items {
			item, _ := v.(*baserootsockshopcomv1.Shipping)
			result[k] = &RootShipping{
				client:   group.client,
				Shipping: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RootSockshopV1().
			Shippings().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RootShipping, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RootShipping{
				client:   group.client,
				Shipping: &item,
			}
		}
	}
	return
}

type RootShipping struct {
	client *Clientset
	*baserootsockshopcomv1.Shipping
}

// Delete removes obj and all it's children from the database.
func (obj *RootShipping) Delete(ctx context.Context) error {
	err := obj.client.Root().DeleteShippingByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Shipping = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RootShipping) Update(ctx context.Context) error {
	result, err := obj.client.Root().UpdateShippingByName(ctx, obj.Shipping)
	if err != nil {
		return err
	}
	obj.Shipping = result.Shipping
	return nil
}

func (obj *RootShipping) GetParent(ctx context.Context) (result *RootSockShop, err error) {
	hashedName := helper.GetHashedName("sockshops.root.sockshop.com", obj.Labels, obj.Labels["sockshops.root.sockshop.com"])
	return obj.client.Root().GetSockShopByName(ctx, hashedName)
}

type shippingRootSockshopV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *shippingRootSockshopV1Chainer) Subscribe() {
	key := "shippings.root.sockshop.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootsockshopcomv1.NewShippingInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
}

func (c *shippingRootSockshopV1Chainer) Unsubscribe() {
	key := "shippings.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *shippingRootSockshopV1Chainer) IsSubscribed() bool {
	key := "shippings.root.sockshop.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *shippingRootSockshopV1Chainer) RegisterEventHandler(addCB func(obj *RootShipping), updateCB func(oldObj, newObj *RootShipping), deleteCB func(obj *RootShipping)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RootShipping")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "shippings.root.sockshop.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootShipping")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootShipping, so creating a new one")
		informer = informerrootsockshopcomv1.NewShippingInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RootShipping{
				client:   c.client,
				Shipping: obj.(*baserootsockshopcomv1.Shipping),
			}

			var parent *RootSockShop
			gvkExist := false
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				// Check GVK

				if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; !ok {
					time.Sleep(500 * time.Millisecond)
					continue
				}

				gvkExist = true
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
				parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !gvkExist {
				// Check GVK

				if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; !ok {
					return
				}

				panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RootShipping{
				client:   c.client,
				Shipping: oldObj.(*baserootsockshopcomv1.Shipping),
			}
			newData := &RootShipping{
				client:   c.client,
				Shipping: newObj.(*baserootsockshopcomv1.Shipping),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RootShipping{
				client:   c.client,
				Shipping: obj.(*baserootsockshopcomv1.Shipping),
			}

			var parent *RootSockShop
			gvkExist := true
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				// Check GVK

				if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; ok {
					time.Sleep(500 * time.Millisecond)
					continue
				}

				gvkExist = false
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
				parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if gvkExist {
				// Check GVK

				if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; ok {
					return
				}

				panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *shippingRootSockshopV1Chainer) RegisterAddCallback(cbfn func(obj *RootShipping)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RootShipping")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "shippings.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] RootShipping Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootShipping{
					client:   c.client,
					Shipping: obj.(*baserootsockshopcomv1.Shipping),
				}

				var parent *RootSockShop
				gvkExist := false
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; !ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = true

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if !gvkExist {
					// Check GVK

					if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; !ok {
						return
					}

					panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] RootShipping Create New Informer")
		informer := informerrootsockshopcomv1.NewShippingInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootShipping{
					client:   c.client,
					Shipping: obj.(*baserootsockshopcomv1.Shipping),
				}

				var parent *RootSockShop
				gvkExist := false
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; !ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = true

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if !gvkExist {
					// Check GVK

					if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; !ok {
						return
					}

					panic(fmt.Sprintf("gvk found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *shippingRootSockshopV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RootShipping)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RootShipping")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "shippings.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] RootShipping Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootShipping{
					client:   c.client,
					Shipping: oldObj.(*baserootsockshopcomv1.Shipping),
				}
				newData := &RootShipping{
					client:   c.client,
					Shipping: newObj.(*baserootsockshopcomv1.Shipping),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] RootShipping Create New Informer")
		informer := informerrootsockshopcomv1.NewShippingInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootShipping{
					client:   c.client,
					Shipping: oldObj.(*baserootsockshopcomv1.Shipping),
				}
				newData := &RootShipping{
					client:   c.client,
					Shipping: newObj.(*baserootsockshopcomv1.Shipping),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *shippingRootSockshopV1Chainer) RegisterDeleteCallback(cbfn func(obj *RootShipping)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RootShipping")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "shippings.root.sockshop.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] RootShipping Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootShipping{
					client:   c.client,
					Shipping: obj.(*baserootsockshopcomv1.Shipping),
				}

				var parent *RootSockShop
				gvkExist := true
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = false
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if gvkExist {
					// Check GVK

					if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; ok {
						return
					}

					panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] RootShipping Create New Informer")
		informer := informerrootsockshopcomv1.NewShippingInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootShipping{
					client:   c.client,
					Shipping: obj.(*baserootsockshopcomv1.Shipping),
				}

				var parent *RootSockShop
				gvkExist := true
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p

					// Check GVK

					if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; ok {
						time.Sleep(500 * time.Millisecond)
						continue
					}

					gvkExist = false

					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("sockshops.root.sockshop.com", nc.Labels, nc.Labels["sockshops.root.sockshop.com"])
					parent, err = c.client.Root().ForceReadSockShopByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				if gvkExist {
					// Check GVK

					if _, ok := parent.Spec.ShippingLedgerGvk[nc.DisplayName()]; ok {
						return
					}

					panic(fmt.Sprintf("gvk not found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}
